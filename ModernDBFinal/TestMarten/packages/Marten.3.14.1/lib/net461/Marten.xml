<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Marten</name>
    </assembly>
    <members>
        <member name="P:Marten.AdvancedOptions.Clean">
            <summary>
                Used to remove document data and tables from the current Postgresql database
            </summary>
        </member>
        <member name="F:Marten.AutoCreate.All">
            <summary>
            Will drop and recreate tables that do not match the Marten configuration or create new ones
            </summary>
        </member>
        <member name="F:Marten.AutoCreate.CreateOrUpdate">
            <summary>
            Will never destroy existing tables. Attempts to add missing columns or missing tables
            </summary>
        </member>
        <member name="F:Marten.AutoCreate.CreateOnly">
            <summary>
            Will create missing schema objects at runtime, but will not update or remove existing schema objects
            </summary>
        </member>
        <member name="F:Marten.AutoCreate.None">
            <summary>
            Do not recreate, destroy, or update schema objects at runtime. Will throw exceptions if
            the schema does not match the Marten configuration
            </summary>
        </member>
        <member name="F:Marten.BulkInsertMode.InsertsOnly">
            <summary>
            Default, fast mode. Will throw an exception if there are any duplicate id's with the existing data
            </summary>
        </member>
        <member name="F:Marten.BulkInsertMode.IgnoreDuplicates">
            <summary>
            Will ignore any documents that already exist in the underlying table storage
            </summary>
        </member>
        <member name="F:Marten.BulkInsertMode.OverwriteExisting">
            <summary>
            Will overwrite the values of any duplicate documents (last update wins)
            </summary>
        </member>
        <member name="T:Marten.ConnectionFactory">
            <summary>
            Default, simple implementation of IConnectionFactory
            </summary>
        </member>
        <member name="M:Marten.ConnectionFactory.#ctor(System.Func{System.String})">
            <summary>
            Supply a lambda that can resolve the connection string
            for a Postgresql database
            </summary>
            <param name="connectionSource"></param>
        </member>
        <member name="M:Marten.ConnectionFactory.#ctor(System.String)">
            <summary>
            Supply the connection string to the Postgresql database directly
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="F:Marten.CreationStyle.DropThenCreate">
            <summary>
            Export DDL by first issuing a DROP statement for a table, then the CREATE statement. This is the default
            </summary>
        </member>
        <member name="F:Marten.CreationStyle.CreateIfNotExists">
            <summary>
            Export DDL for table creation by using a CREATE IF NOT EXISTS clause w/o a prior DROP statement
            </summary>
        </member>
        <member name="P:Marten.DdlRules.TableCreation">
            <summary>
                Alters the syntax used to create tables in DDL
            </summary>
        </member>
        <member name="P:Marten.DdlRules.UpsertRights">
            <summary>
                Alters the user rights for the upsert functions in DDL
            </summary>
        </member>
        <member name="P:Marten.DdlRules.Role">
            <summary>
                Option to use this database role during DDL scripts
            </summary>
        </member>
        <member name="M:Marten.DdlRules.ReadTemplates(System.String)">
            <summary>
            Read [name].table and [name].function files from the named directory
            to serve as templates for extra DDL (GRANT's probably)
            </summary>
            <param name="directory"></param>
        </member>
        <member name="M:Marten.DdlRules.ReadTemplates">
            <summary>
            Read DDL templates from the application base directory
            </summary>
        </member>
        <member name="P:Marten.DocumentSession.Concurrency">
            <summary>
            Use to enable or disable optimistic concurrency checks for this session
            </summary>
        </member>
        <member name="T:Marten.DocumentStore">
            <summary>
            The main entry way to using Marten
            </summary>
        </member>
        <member name="M:Marten.DocumentStore.For(System.String)">
            <summary>
            Quick way to stand up a DocumentStore to the given database connection
            in the "development" mode for auto-creating schema objects as needed
            with the default behaviors
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.DocumentStore.For``1">
            <summary>
            Configures a DocumentStore for an existing StoreOptions type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.DocumentStore.For(System.Action{Marten.StoreOptions})">
            <summary>
            Configures a DocumentStore by defining the StoreOptions settings first
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.DocumentStore.#ctor(Marten.StoreOptions)">
            <summary>
            Creates a new DocumentStore with the supplied StoreOptions
            </summary>
            <param name="options"></param>
        </member>
        <member name="P:Marten.Events.IEvent.Data">
            <summary>
            The actual event data body
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.StreamId">
            <summary>
            If using Guid's for the stream identity, this will
            refer to the Stream's Id, otherwise it will always be Guid.Empty
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.StreamKey">
            <summary>
            If using strings as the stream identifier, this will refer
            to the containing Stream's Id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Timestamp">
            <summary>
            The UTC time that this event was originally captured
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.TenantId">
            <summary>
            If using multi-tenancy by tenant id
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.StreamId">
            <summary>
            A reference to the stream that contains
            this event
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.StreamKey">
            <summary>
            A reference to the stream if the stream
            identier mode is AsString
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Id">
            <summary>
            An alternative Guid identifier to identify
            events across databases
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Version">
            <summary>
            An event's version position within its event stream
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Sequence">
            <summary>
            A global sequential number identifying the Event
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Data">
            <summary>
            The actual event data
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Timestamp">
            <summary>
            The UTC time that this event was originally captured
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.UseAppendEventForUpdateLock">
            <summary>
                Whether a "for update" (row exclusive lock) should be used when selecting out the event version to use from the streams table
            </summary>
            <remkarks>
                Not using this can result in race conditions in a concurrent environment that lead to
                  event version mismatches between the event and stream version numbers
            </remkarks>
        </member>
        <member name="M:Marten.Events.EventGraph.UseAggregatorLookup(Marten.Events.Projections.IAggregatorLookup)">
            <summary>
            Set default strategy to lookup IAggregator when no explicit IAggregator registration exists.
            </summary>
            <remarks>Unless called, <see cref="T:Marten.Events.Projections.AggregatorLookup"/> is used</remarks>
        </member>
        <member name="M:Marten.Events.EventStream.Add``1(``0)">
            <summary>
            Strictly for testing
            </summary>
            <typeparam name="T"></typeparam>
            <param name="@event"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.Guid,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.String,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.Guid,System.Int32,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.Guid,System.Int32,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.String,System.Int32,System.Object[])">
            <summary>
            Append one or more events in order to an existing stream and verify that maximum event id for the stream
            matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.Guid,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Type,System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <param name="aggregateType"></param>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Type,System.Guid,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <param name="aggregateType"></param>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.String,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="aggregateType"></param>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="aggregateType"></param>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Guid,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.String,System.Object[])">
            <summary>
            Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.Object[])">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Type,System.Object[])">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream(System.Object[])">
            <summary>
            Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
             - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStream(System.Guid,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStreamAsync(System.Guid,System.Int32,System.Nullable{System.DateTime},System.Threading.CancellationToken)">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStream(System.String,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStreamAsync(System.String,System.Int32,System.Nullable{System.DateTime},System.Threading.CancellationToken)">
            <summary>
            Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AggregateStream``1(System.Guid,System.Int32,System.Nullable{System.DateTime},``0)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamId"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <param name="state">Instance of T to apply events to</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AggregateStreamAsync``1(System.Guid,System.Int32,System.Nullable{System.DateTime},``0,System.Threading.CancellationToken)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamId"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <param name="state">Instance of T to apply events to</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AggregateStream``1(System.String,System.Int32,System.Nullable{System.DateTime},``0)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamKey"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <param name="state">Instance of T to apply events to</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AggregateStreamAsync``1(System.String,System.Int32,System.Nullable{System.DateTime},``0,System.Threading.CancellationToken)">
            <summary>
            Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamKey"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <param name="state">Instance of T to apply events to</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.QueryRawEventDataOnly``1">
            <summary>
            Query directly against ONLY the raw event data. Use IQuerySession.Query() for aggregated documents!
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.QueryAllRawEvents">
            <summary>
            Query directly against the raw event data across all event types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.Load``1(System.Guid)">
            <summary>
            Load a single event by its id knowing the event type upfront
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.LoadAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Load a single event by its id knowing the event type upfront
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.Load(System.Guid)">
            <summary>
            Load a single event by its id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.LoadAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Load a single event by its id
            </summary>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStreamState(System.Guid)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStreamStateAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamId"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStreamState(System.String)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamKey"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchStreamStateAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Fetches only the metadata about a stream by id
            </summary>
            <param name="streamKey"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.AggregateFinder`1">
            <summary>
            Simple aggregation finder that looks for an aggregate document based on the stream id
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.AggregatorApplyPrivate`1">
            <summary>
            Customize behaviour of <see cref="T:Marten.Events.Projections.Aggregator`1" /> by using private Apply methods in aggregation.
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.AggregatorApplyPublicAndPrivate`1">
            <summary>
            Customize behaviour of <see cref="T:Marten.Events.Projections.Aggregator`1" /> by using private Apply methods in aggregation.
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.AggregatorLookup">
            <summary>
            Default IAggregator lookup strategy. Defaults to <see cref="T:Marten.Events.Projections.Aggregator`1"/>
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.AggregatorLookup.#ctor(System.Func{System.Type,Marten.Events.Projections.IAggregator})">
            <param name="factory">Factory for resolving IAggregator for the supplied type</param>
        </member>
        <member name="P:Marten.Events.Projections.Async.AsyncOptions.PageSize">
            <summary>
            "Page" size of events that expresses a maximum count to fetch in the async daemon.
            Default is 100.
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.Async.AsyncOptions.MaximumStagedEventCount">
            <summary>
            Maximum number of events to buffer in memory before pausing the fetching.
            The default is 1000
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.Async.AsyncOptions.CooldownStagedEventCount">
            <summary>
            Lower threshold of staged events in memory for a projection before
            the Async Daemon resumes fetching. The default is
            500
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.Async.ProjectionExtensions.PageSize(Marten.Events.Projections.IProjection,System.Int32)">
            <summary>
            "Page" size of events that expresses a maximum count to fetch in the async daemon.
            Default is 100.
            </summary>
            <param name="projection"></param>
            <param name="pageSize"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Async.ProjectionExtensions.MaximumStagedEventCount(Marten.Events.Projections.IProjection,System.Int32)">
            <summary>
            Maximum number of events to buffer in memory before pausing the fetching.
            The default is 1000
            </summary>
            <param name="projection"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Async.ProjectionExtensions.CooldownStagedEventCount(Marten.Events.Projections.IProjection,System.Int32)">
            <summary>
            Lower threshold of staged events in memory for a projection before
            the Async Daemon resumes fetching. The default is
            500
            </summary>
            <param name="projection"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.IAggregatorLookup">
            <summary>
            Used by <see cref="T:Marten.Events.EventGraph"/> to resolve IAggregator when no explicit IAggregator registration exists
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.IAggregatorLookup.Lookup``1">
            <summary>
            Resolve aggregator for T
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.IAggregatorLookup.Lookup(System.Type)">
            <summary>
            Resolve aggregator for aggregateType
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IDocumentProjection">
            <summary>
            Marks a projection as producing a single type of Marten document
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.StringIdentifiedAggregateFinder`1">
            <summary>
            Simple aggregation finder that looks for an aggregate document based on the stream key
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandException">
            <summary>
            Wraps the Postgres command exceptions. Unifies exception handling and brings additonal information.
            </summary>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandExceptionFactory">
            <summary>
            Class responsible for creating MartenCommandException exception or exceptions derived from it based on exact command code.
            </summary>
        </member>
        <member name="T:Marten.Exceptions.NotSupportedReason">
            <summary>
            Reasons for feature not being supported
            </summary>
        </member>
        <member name="F:Marten.Exceptions.NotSupportedReason.FullTextSearchNeedsAtLeastPostgresVersion10">
            <summary>
            Full Text Search needs at least Postgres version 10 - eg. doing PlainTextSearch or using to_tsvector
            </summary>
        </member>
        <member name="F:Marten.Exceptions.NotSupportedReason.WebStyleSearchNeedsAtLeastPostgresVersion11">
            <summary>
            Web Styles Search needs at least Postgres version 11
            </summary>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandNotSupportedException">
            <summary>
            Informs that feature used in Postgres command is not supported
            </summary>
        </member>
        <member name="P:Marten.Exceptions.MartenCommandNotSupportedException.Reason">
            <summary>
            Reason for feature not being supported
            </summary>
        </member>
        <member name="M:Marten.Exceptions.MartenCommandNotSupportedException.#ctor(Marten.Exceptions.NotSupportedReason,Npgsql.NpgsqlCommand,System.Exception,System.String)">
             <summary>
            
             Creates MartenCommandNotSupportedException based on the reason, command and innerException information with formatted message.
             </summary>
             <param name="reason">reason for feature not being supported</param>
             <param name="command">failed Postgres command</param>
             <param name="innerException">internal exception details</param>
             <param name="message">optional additional exception information</param>
        </member>
        <member name="P:Marten.Schema.FullTextIndexAttribute.IndexName">
            <summary>
            Specify the name of the index explicity
            </summary>
        </member>
        <member name="F:Marten.Schema.FullTextIndexAttribute.RegConfig">
            <summary>
            Specify Index type
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.IsUnique">
            <summary>
            Creates the index as UNIQUE
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.IsConcurrent">
            <summary>
            Specifies the index should be created in the background and not block/lock
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.IndexName">
            <summary>
            Specify the name of the index explicity
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.Where">
            <summary>
            Allows you to specify a where clause on the index
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.Casing">
            <summary>
            Marks the column value as upper/lower casing
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.Method">
            <summary>
            Specifies the type of index to create
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.SortOrder">
            <summary>
            Specifies the sort order of the index (only applicable to B-tree indexes)
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.TenancyScope">
            <summary>
            Specifies the unique index is scoped to the tenant
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Default">
            <summary>
            Leave the casing as is (default)
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Upper">
            <summary>
            Change the casing to uppercase
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Lower">
            <summary>
            Change the casing to lowercase
            </summary>
        </member>
        <member name="T:Marten.Schema.DatabaseSchemaNameAttribute">
            <summary>
            Overrides the database schema name for the document type
            </summary>
        </member>
        <member name="M:Marten.Schema.DbObjectName.#ctor(System.String)">
            <summary>
            Create a DbObjectName with Schema = "public"
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Marten.Schema.DdlTemplateAttribute">
            <summary>
            Override the DDL template for a single document type
            </summary>
        </member>
        <member name="T:Marten.Schema.DocumentAliasAttribute">
            <summary>
            Used to alter the document type alias with Marten to
            avoid naming collisions in the underlying Postgresql
            schema from similarly named document
            types
            </summary>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddFullTextIndex(System.String,System.Action{Marten.Schema.FullTextIndex})">
            <summary>
            Adds a full text index
            </summary>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <param name="configure">Optional action to further configure the full text index</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddFullTextIndex(System.Reflection.MemberInfo[][],System.String,System.String)">
            <summary>
            Adds a full text index
            </summary>
            <param name="members">Document fields that should be use by full text index</param>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Duplicate(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.IndexDefinition},System.Boolean)">
            <summary>
            Marks a property or field on this document type as a searchable field that is also duplicated in the
            database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">Optional, allows you to customize the Postgresql database index configured for the duplicated field</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.AddSubClassHierarchy(Marten.MappedType[])">
            <summary>
            Programmatically directs Marten to map all the subclasses of <cref name="T"/> to a hierarchy of types
            </summary>
            <param name="allSubclassTypes">All the subclass types of <cref name="T"/> that you wish to map.
            You can use either params of <see cref="T:System.Type"/> or <see cref="T:Marten.MappedType"/> or a mix, since Type can implicitly convert to MappedType (without an alias)</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.AddSubClassHierarchy">
            <summary>
            Programmatically directs Marten to map all the subclasses of <cref name="T"/> to a hierarchy of types. <c>Unadvised in projects with many types.</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Index(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
            Adds a computed index
            </summary>
            <param name="expression"></param>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Index(System.Collections.Generic.IReadOnlyCollection{System.Linq.Expressions.Expression{System.Func{`0,System.Object}}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
            Adds a computed index
            </summary>
            <param name="expressions"></param>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.FullTextIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Adds a full text index with default region config set to 'english'
            </summary>
            <param name="expressions">Document fields that should be use by full text index</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.FullTextIndex(System.Action{Marten.Schema.FullTextIndex},System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Adds a full text index with default region config set to 'english'
            </summary>
            <param name="expressions">Document fields that should be use by full text index</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.FullTextIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Adds a full text index
            </summary>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <param name="expressions">Document fields that should be use by full text index</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.ForeignKey``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.ForeignKeyDefinition},System.Action{Marten.Schema.IndexDefinition})">
            <summary>
            Adds foreign key index to other marten document
            </summary>
            <typeparam name="TReference">Document type</typeparam>
            <param name="expression">Field selector</param>
            <param name="foreignKeyConfiguration">customize foreign key configuration</param>
            <param name="indexConfiguration">customize index configuration</param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.ForeignKey(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.String,System.String,System.Action{Marten.Schema.ExternalForeignKeyDefinition})">
            <summary>
            Adds foreign key index to non-marten table
            </summary>
            <param name="expression">Field selector</param>
            <param name="tableName">external table name</param>
            <param name="columnName">referenced column to external table</param>
            <param name="schemaName">external table schema name, if not provided then DatabaseSchemaName from store options will be used</param>
            <param name="foreignKeyConfiguration">customize foreign key configuration</param>
        </member>
        <member name="P:Marten.Schema.DuplicatedField.DbType">
            <summary>
            Used to override the assigned DbType used by Npgsql when a parameter
            is used in a query against this column
            </summary>
        </member>
        <member name="T:Marten.Schema.DuplicateFieldAttribute">
            <summary>
            Mark a single property or field on a document as a duplicated, searchable field
            for optimized searching
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.PgType">
            <summary>
            Use to override the Postgresql database column type of this searchable field
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.DbType">
            <summary>
            Use to override the NpgsqlDbType used when querying with a parameter
            against the property
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexMethod">
            <summary>
            Specifies the type of index to create
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexName">
            <summary>
            Specify the name of the index explicity
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexSortOrder">
            <summary>
            Specifies the sort order of the index (only applicable to B-tree indexes)
            </summary>
        </member>
        <member name="T:Marten.Schema.GinIndexedAttribute">
            <summary>
            Adds a gin index to the JSONB data of a document
            </summary>
        </member>
        <member name="T:Marten.Schema.HiloSequenceAttribute">
            <summary>
            Use to customize the Hilo sequence generation for a single document type
            </summary>
        </member>
        <member name="M:Marten.Schema.IDatabaseCreationExpressions.ForTenant(System.String)">
            <param name="tenantId">If omitted, configure for default tenancy</param>
        </member>
        <member name="M:Marten.Schema.IDatabaseCreationExpressions.MaintenanceDatabase(System.String)">
            <summary>
            Setup the maintenance database to which to connect to prior to database creation.
            If not specified, the store connection string with 'postgres' as database is used.
            </summary>
        </member>
        <member name="M:Marten.Schema.IDbObjects.SchemaTables">
            <summary>
            Fetches a list of all of the Marten generated tables
            in the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDbObjects.DocumentTables">
            <summary>
            Fetches a list of the Marten document tables
            in the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDbObjects.Functions">
            <summary>
            Fetches a list of functions generated by Marten
            in the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDbObjects.TableExists(Marten.Schema.DbObjectName)">
            <summary>
            Checks whether or not a database table exists in the current tenant
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDbObjects.AllIndexes">
            <summary>
            Query for the Marten related indexes in the current tenant
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDbObjects.IndexesFor(Marten.Schema.DbObjectName)">
            <summary>
            Query for the indexes related to the named table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDbObjects.DefinitionForFunction(Marten.Schema.DbObjectName)">
            <summary>
            Query for the designated FunctionBody
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Schema.Identity.CombGuidIdGeneration">
            <summary>
                Comb Guid Id Generation. More info http://www.informit.com/articles/article.aspx?p=25862
            </summary>
        </member>
        <member name="M:Marten.Schema.Identity.CombGuidIdGeneration.NewGuid(System.DateTimeOffset)">
            <summary>
                Returns a new Guid COMB, consisting of a random Guid combined with the provided timestamp.
            </summary>
        </member>
        <member name="T:Marten.Schema.IdentityAttribute">
            <summary>
            Use to designate an Id property or field on a document type that doesn't follow the
            id/Id naming convention
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllDocuments">
            <summary>
            Deletes all existing document data in the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsFor(System.Type)">
            <summary>
            Deletes all the existing document data for the specified document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsExcept(System.Type[])">
            <summary>
            Delete all document data *except* for the specified document types.
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemove(System.Type)">
            <summary>
            Drop all the schema objects in the underlying Postgresql database for the specified
            document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemoveAll">
            <summary>
            Remove all Marten-related schema objects from the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllEventData">
            <summary>
            Completely deletes all the event and stream data
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStream(System.Guid)">
            <summary>
            Deletes all stream and event data for the designated streamId. Will
            not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStream(System.String)">
            <summary>
            Deletes all stream and event data for the designated streamId. Will
            not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.WriteDDL(System.String,System.Boolean)">
            <summary>
                Write the SQL script to build the database schema
                objects to a file
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.WriteDDLByType(System.String,System.Boolean)">
            <summary>
                Write all the SQL scripts to build the database schema, but
                split by document type
            </summary>
            <param name="directory"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.ToDDL(System.Boolean)">
            <summary>
                Creates all the SQL script that would build all the database
                schema objects for the configured schema
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.WritePatch(System.String,System.Boolean,System.Boolean)">
            <summary>
                Tries to write a "patch" SQL file to upgrade the database
                to the current Marten schema configuration. Also writes a corresponding
                rollback file as well.
            </summary>
            <param name="filename"></param>
            <param name="withSchemas"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.ToPatch(System.Boolean,System.Boolean)">
            <summary>
                Tries to write a "patch" SQL text to upgrade the database
                to the current Marten schema configuration
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.AssertDatabaseMatchesConfiguration">
            <summary>
                Validates the Marten configuration of documents and transforms against
                the current database schema. Will throw an exception if any differences are
                detected. Useful for "environment tests"
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.ApplyAllConfiguredChangesToDatabase(System.Nullable{Marten.AutoCreate})">
            <summary>
                Executes all detected DDL patches to the schema based on current configuration
                upfront at one time
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentSchema.ToPatch(System.Type)">
            <summary>
                Generate a DDL patch for one specific document type
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Schema.IndexedLastModifiedAttribute">
            <summary>
            Creates an index on the predefined Last Modified column
            </summary>
        </member>
        <member name="T:Marten.Schema.ITenantDatabaseCreationExpressions">
            <summary>
            Specify options that are passed to CREATE DATABASE.
            <see href="https://www.postgresql.org/docs/current/static/sql-createdatabase.html">CREATE DATABASE</see> documentation for options.
            </summary>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.DropExisting(System.Boolean)">
            <summary>
            If database exists, it is dropped prior to re-creation.
            </summary>
            <param name="killConnections">Kill connections to database prior to drop</param>
            <remarks>Requires CREATEDB privilege</remarks>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.CheckAgainstPgDatabase">
            <summary>
            Check for database existence from pg_database, otherwise detect "INVALID CATALOG NAME" on connect
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.OnDatabaseCreated(System.Action{Npgsql.NpgsqlConnection})">
            <summary>
            Callback to be invoked after database creation
            </summary>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.CreatePLV8">
            <summary>
            Create PLV8 extension for database
            </summary>
        </member>
        <member name="T:Marten.Schema.MartenAttribute">
            <summary>
            Base type of an Attribute that can be extended to add per field/property
            or per document type customization to the document storage
            </summary>
        </member>
        <member name="M:Marten.Schema.MartenAttribute.Modify(Marten.Schema.DocumentMapping)">
            <summary>
            Customize Document storage at the document level
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="M:Marten.Schema.MartenAttribute.Modify(Marten.Schema.DocumentMapping,System.Reflection.MemberInfo)">
            <summary>
            Customize the Document storage for a single member
            </summary>
            <param name="mapping"></param>
            <param name="member"></param>
        </member>
        <member name="T:Marten.Schema.MultiTenantedAttribute">
            <summary>
            Directs Marten to store this document type with conjoined multi-tenancy
            </summary>
        </member>
        <member name="F:Marten.Schema.PropertySearching.JSON_Locator_Only">
            <summary>
            Uses Postgresql's JSON locators to search within JSON data
            </summary>
        </member>
        <member name="F:Marten.Schema.PropertySearching.ContainmentOperator">
            <summary>
            Tries to use Postgresql's @> containment operator to search within JSON data
            </summary>
        </member>
        <member name="T:Marten.Schema.PropertySearchingAttribute">
            <summary>
            Customize the PropertySearching mode of a single document type
            </summary>
        </member>
        <member name="T:Marten.Schema.SoftDeletedAttribute">
            <summary>
            Marks a document type as "soft deleted"
            </summary>
        </member>
        <member name="P:Marten.Schema.SoftDeletedAttribute.Indexed">
            <summary>
            Creates an index on deleted documents
            </summary>
        </member>
        <member name="T:Marten.Schema.StructuralTypedAttribute">
            <summary>
            Allows you to duplicate storage with other classes of the same name
            </summary>
        </member>
        <member name="T:Marten.Schema.UseOptimisticConcurrencyAttribute">
            <summary>
            Directs Marten to use optimistic versioning checks when updating this document type
            </summary>
        </member>
        <member name="T:Marten.Schema.VersionAttribute">
            <summary>
            Direct Marten to make a field or property on a document be
            set and tracked as the document version.
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IsConcurrent">
            <summary>
            Specifies the index should be created in the background and not block/lock
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IndexMethod">
            <summary>
            Specifies the type of index to create
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IndexName">
            <summary>
            Specify the name of the index explicity
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexAttribute.IndexType">
            <summary>
            Specify Index type
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexAttribute.TenancyScope">
            <summary>
            Specify Tenancy for unique index
            </summary>
        </member>
        <member name="T:Marten.IConnectionFactory">
            <summary>
            Factory interface to customize the construction of an NpgsqlConnection
            to the Postgresql database
            </summary>
        </member>
        <member name="M:Marten.IConnectionFactory.Create">
            <summary>
            Create a new, isolated connection to the Postgresql database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDiagnostics.PreviewCommand``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Preview the database command that will be executed for this compiled query
            object
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDiagnostics.ExplainPlan``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Find the Postgresql EXPLAIN PLAN for this compiled query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDiagnostics.GetPostgresVersion">
            <summary>
            Method to fetch Postgres server version
            </summary>
            <returns>Returns version</returns>
        </member>
        <member name="T:Marten.IDocumentSession">
            <summary>
            Interface for querying a document database and unit of work updates
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.Delete``1(``0)">
            <summary>
            Mark this entity for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Delete``1(System.Int32)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Delete``1(System.Int64)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Delete``1(System.Guid)">
            <summary>
            Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Delete``1(System.String)">
            <summary>
            Mark an entity of type T with a string id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentSession.DeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Bulk delete all documents of type T matching the expression condition
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.IDocumentSession.SaveChanges">
            <summary>
            Saves all the pending changes and deletions to the server in a single Postgresql transaction.
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.SaveChangesAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously saves all the pending changes and deletions to the server in a single Postgresql transaction
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.Store``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Explicitly marks multiple documents as needing to be inserted or updated upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Store``1(``0[])">
            <summary>
            Explicitly marks one or more documents as needing to be inserted or updated upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Store``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Explicitly marks multiple documents as needing to be inserted or updated upon the next call to SaveChanges()
            to a specific tenant
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Store``1(System.String,``0[])">
            <summary>
            Explicitly marks one or more documents as needing to be inserted or updated upon the next call to SaveChanges()
            to a specific tenant
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Store``1(``0,System.Guid)">
            <summary>
            Explicitly marks a document as needing to be updated and supplies the
            current known version for the purpose of optimistic versioning checks
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
            <param name="version"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Insert``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Explicitly marks a document as needing to be inserted upon the next call to SaveChanges().
            Will throw an exception if the document already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Insert``1(``0[])">
            <summary>
            Explicitly marks a document as needing to be inserted upon the next call to SaveChanges().
            Will throw an exception if the document already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Update``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Explicitly marks a document as needing to be updated upon the next call to SaveChanges().
            Will throw an exception if the document does not already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Update``1(``0[])">
            <summary>
            Explicitly marks a document as needing to be updated upon the next call to SaveChanges().
            Will throw an exception if the document does not already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentSession.InsertObjects(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Insert an enumerable of potentially mixed documents. Will throw exceptions
            if a document overwrite is detected
            </summary>
            <param name="documents"></param>
        </member>
        <member name="P:Marten.IDocumentSession.PendingChanges">
            <summary>
            List of all the pending changes to this IDocumentSession
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.StoreObjects(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            DocumentStore an enumerable of potentially mixed documents
            </summary>
            <param name="documents"></param>
        </member>
        <member name="P:Marten.IDocumentSession.Events">
            <summary>
            Access to the event store functionality
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Concurrency">
            <summary>
            Override whether or not this session honors optimistic concurrency checks
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Listeners">
            <summary>
            Writeable list of the listeners for this session
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.Patch``1(System.Int32)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.Patch``1(System.Int64)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.Patch``1(System.String)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.Patch``1(System.Guid)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.Patch``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.Patch``1(Marten.Linq.IWhereFragment)">
            <summary>
            Patch multiple documents matching the supplied where fragment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fragment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.QueueOperation(Marten.Services.IStorageOperation)">
            <summary>
            Catch all mechanism to add additional database calls to the batched
            updates in SaveChanges()/SaveChangesAsync()
            </summary>
            <param name="storageOperation"></param>
        </member>
        <member name="M:Marten.IDocumentSession.Eject``1(``0)">
            <summary>
            Completely remove the document from this session's unit of work tracking and identity map caching
            </summary>
            <typeparam name="T"></typeparam>
            <param name="document"></param>
        </member>
        <member name="M:Marten.IDocumentSession.EjectAllOfType(System.Type)">
            <summary>
            Completely remove all the documents of given type from this session's unit of work tracking and identity map caching
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ById``1(``0[])">
            <summary>
            Supply the document id's to load
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ByIdAsync``1(``0[])">
            <summary>
            Supply the document id's to load asynchronously
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ById``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Supply the document id's to load
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ByIdAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Supply the document id's to load asynchronously
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSessionListener.BeforeSaveChanges(Marten.IDocumentSession)">
            <summary>
            Called just after IDocumentSession.SaveChanges() is called, but before
            any database calls are made
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:Marten.IDocumentSessionListener.BeforeSaveChangesAsync(Marten.IDocumentSession,System.Threading.CancellationToken)">
            <summary>
            Called just after IDocumentSession.SaveChanges() is called,
            but before any database calls are made
            </summary>
            <param name="session"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSessionListener.AfterCommit(Marten.IDocumentSession,Marten.Services.IChangeSet)">
            <summary>
            After an IDocumentSession is committed
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
        </member>
        <member name="M:Marten.IDocumentSessionListener.AfterCommitAsync(Marten.IDocumentSession,Marten.Services.IChangeSet,System.Threading.CancellationToken)">
            <summary>
            After an IDocumentSession is committed
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSessionListener.DocumentLoaded(System.Object,System.Object)">
            <summary>
            Called after a document is loaded
            </summary>
        </member>
        <member name="M:Marten.IDocumentSessionListener.DocumentAddedForStorage(System.Object,System.Object)">
            <summary>
            Called after a document is explicitly added to a session
            as a staged insert or update
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Schema">
            <summary>
                Information about the document and event storage
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Advanced">
            <summary>
                Infrequently used operations like document cleaning and the initial store configuration
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Diagnostics">
            <summary>
                Access to Marten's diagnostics for trouble shooting
            </summary>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsert``1(System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsert``1(System.String,System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tenantId"></param>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(Marten.DocumentTracking,System.Data.IsolationLevel)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="tracking"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(System.String,Marten.DocumentTracking,System.Data.IsolationLevel)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="tracking"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(Marten.Services.SessionOptions)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="options">Additional options for session</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSession(System.Data.IsolationLevel)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSession(System.String,System.Data.IsolationLevel)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSession(System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSession(System.String,System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession(System.String)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession(Marten.Services.SessionOptions)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <param name="options">Additional options for session. DocumentTracking is not applicable for IQuerySession.</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocuments(System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocuments(System.String,System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="P:Marten.IDocumentStore.Transform">
            <summary>
            Use Javascript transformations to alter existing documents
            </summary>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.String)">
            <summary>
            Load or find only the document json by string id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Int32)">
            <summary>
            Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Int64)">
            <summary>
            Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Guid)">
            <summary>
            Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by string id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Int64,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.IMartenLogger">
            <summary>
            Records command usage, schema changes, and sessions within Marten
            </summary>
        </member>
        <member name="T:Marten.IMartenSessionLogger">
            <summary>
            Use to create custom logging within an IQuerySession or IDocumentSession
            </summary>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogSuccess(Npgsql.NpgsqlCommand)">
            <summary>
            Log a command that executed successfully
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogFailure(Npgsql.NpgsqlCommand,System.Exception)">
            <summary>
            Log a command that failed
            </summary>
            <param name="command"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.RecordSavedChanges(Marten.IDocumentSession,Marten.Services.IChangeSet)">
            <summary>
            Called immediately after committing an IDocumentSession
            through SaveChanges() or SaveChangesAsync()
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.String)">
            <summary>
            Find or load a single document of type T by a string id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously find or load a single document of type T by a string id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Int32)">
            <summary>
            Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Int64)">
            <summary>
            Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Guid)">
            <summary>
            Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Int64,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Query``1">
            <summary>
            Use Linq operators to query the documents
            stored in Postgresql
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Query``1(System.String,System.Object[])">
            <summary>
            Queries the document storage table for the document type T by supplied SQL. See http://jasperfx.github.io/marten/documentation/documents/querying/sql/ for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``1(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Asynchronously queries the document storage table for the document type T by supplied SQL. See http://jasperfx.github.io/marten/documentation/documents/querying/sql/ for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.CreateBatchQuery">
            <summary>
            Define a batch of deferred queries and load operations to be conducted in one asynchronous request to the
            database for potentially performance
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.IQuerySession.Connection">
            <summary>
            The currently open Npgsql connection for this session. Use with caution.
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.Logger">
            <summary>
            The session specific logger for this session. Can be set for better integration
            with custom diagnostics
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.RequestCount">
            <summary>
            Request count
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.DocumentStore">
            <summary>
            The document store that created this session
            </summary>
        </member>
        <member name="M:Marten.IQuerySession.Query``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            A query that is compiled so a copy of the DbCommand can be used directly in subsequent requests.
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output</typeparam>
            <param name="query">The instance of a compiled query</param>
            <returns>A single item query result</returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``2(Marten.Linq.ICompiledQuery{``0,``1},System.Threading.CancellationToken)">
            <summary>
            An async query that is compiled so a copy of the DbCommand can be used directly in subsequent requests.
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output</typeparam>
            <param name="query">The instance of a compiled query</param>
            <param name="token">A cancellation token</param>
            <returns>A task for a single item query result</returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.String[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Guid[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Int32[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Int64[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.String[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Guid[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Int32[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Int64[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.String[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Guid[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Int32[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Int64[])">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Marten.IQuerySession.Json">
            <summary>
            Directly load the persisted JSON data for documents by Id
            </summary>
        </member>
        <member name="M:Marten.IQuerySession.VersionFor``1(``0)">
            <summary>
            Retrieve the current known version of the given document
            according to this session. Will return null if the document is
            not part of this session
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Search``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.SearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PlainTextSearch``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PlainTextSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PhraseSearch``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PhraseSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.WebStyleSearch``1(System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <param name="regConfig">The dictionary config passed to the 'websearch_to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.WebStyleSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Performs an asynchronous full text search against <typeparamref name="TDoc"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <param name="regConfig">The dictionary config passed to the 'websearch_to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <param name="token"></param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="T:Marten.IRetryPolicy">
            <summary>
            Interface defining the retry policy for handling NpgqlException with transient failures
            </summary>
        </member>
        <member name="M:Marten.IRetryPolicy.Execute(System.Action)">
            <summary>
            Execute operation with the relevant retry policy
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Marten.IRetryPolicy.Execute``1(System.Func{``0})">
            <summary>
            Execute operation with the relevant retry policy and return result
            </summary>
            <param name="operation"></param>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IRetryPolicy.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Async execute operation with the relevant retry policy
            </summary>
            <param name="operation"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IRetryPolicy.ExecuteAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Async Execute operation with the relevant retry policy and return result
            </summary>
            <param name="operation"></param>
            <param name="cancellationToken"></param>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.NulloRetryPolicy">
            <summary>
            No-op implementation of IRetryPolicy
            </summary>
        </member>
        <member name="T:Marten.DefaultRetryPolicy">
            <summary>
            Default retry policy, which accounts for <see cref="P:Npgsql.NpgsqlException.IsTransient"/>.
            </summary>
            <remarks>
            Based on example https://martendb.io/documentation/documents/advanced/retrypolicy/ by Joona-Pekka Kokko.
            </remarks>
        </member>
        <member name="M:Marten.DefaultRetryPolicy.Once(System.Func{System.Exception,System.Boolean},System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Initializes a retry policy that will retry once after failure that matches the filter.
            </summary>
            <param name="filter">Optional filter when to apply, default to checking for <see cref="P:Npgsql.NpgsqlException.IsTransient"/></param>
            <param name="sleep">Optional sleep after exception, gets retry number 1-N as parameter, defaults to sleeping retry number seconds</param>
            <returns>The configured retry policy.</returns>
        </member>
        <member name="M:Marten.DefaultRetryPolicy.Twice(System.Func{System.Exception,System.Boolean},System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Initializes a retry policy that will retry twice after failure that matches the filter.
            </summary>
            <param name="filter">Optional filter when to apply, default to checking for <see cref="P:Npgsql.NpgsqlException.IsTransient"/></param>
            <param name="sleep">Optional sleep after exception, gets retry number 1-N as parameter, defaults to sleeping retry number seconds</param>
            <returns>The configured retry policy.</returns>
        </member>
        <member name="M:Marten.DefaultRetryPolicy.Times(System.Int32,System.Func{System.Exception,System.Boolean},System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Initializes a retry policy that will retry given amount of times after failure.
            </summary>
            <param name="maxRetryCount">How many times the operation will be retried on failure that matches the filter.</param>
            <param name="filter">Optional filter when to apply, default to checking for <see cref="P:Npgsql.NpgsqlException.IsTransient"/></param>
            <param name="sleep">Optional sleep after exception, gets retry number 1-N as parameter, defaults to sleeping retry number seconds</param>
            <returns>The configured retry policy.</returns>
        </member>
        <member name="M:Marten.ISerializer.ToJson(System.Object,System.IO.TextWriter)">
            <summary>
            Serialize the document object into <paramref name="writer"/>.
            </summary>
            <param name="document"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Marten.ISerializer.ToJson(System.Object)">
            <summary>
            Serialize the document object into a JSON string
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ISerializer.FromJson``1(System.IO.TextReader)">
            <summary>
            Deserialize a JSON string into an object of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ISerializer.FromJson(System.Type,System.IO.TextReader)">
            <summary>
            Deserialize a JSON string into the supplied Type
            </summary>
            <param name="type"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ISerializer.ToCleanJson(System.Object)">
            <summary>
            Serialize a document without any extra
            type handling metadata
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.ISerializer.EnumStorage">
            <summary>
            Just gotta tell Marten if enum's are stored
            as int's or string's in the JSON
            </summary>
        </member>
        <member name="P:Marten.ISerializer.Casing">
            <summary>
            Specify whether properties in the JSON document should use Camel or Pascal casing.
            </summary>
        </member>
        <member name="P:Marten.ISerializer.CollectionStorage">
            <summary>
            Specify whether collections should be stored as json arrays (without type names)
            </summary>
        </member>
        <member name="P:Marten.ISerializer.NonPublicMembersStorage">
            <summary>
            Specify whether non public members should be used during deserialization
            </summary>
        </member>
        <member name="T:Marten.Linq.CollectionAnyNoPredicateWhereFragment">
            <summary>
            Handle Any() with JSONB_ARRAY_LENGTH introduced in PostgreSQL 9.4
            </summary>
        </member>
        <member name="T:Marten.Linq.FetchType">
            <summary>
            In basic terms, how is the IQueryable going to be executed?
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.FetchOne">
            <summary>
            First/FirstOrDefault/Single/SingleOrDefault
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.FetchMany">
            <summary>
            Any execution that returns an IEnumerable (ToArray()/ToList()/etc.)
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.Count">
            <summary>
            Using IQueryable.Count()
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.Any">
            <summary>
            Using IQueryable.Any()
            </summary>
        </member>
        <member name="T:Marten.Linq.ICompiledQuery`2">
            <summary>
            Used to express a query expression that when used will be cached by class type implementing this interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The result type for a query</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledListQuery`1">
            <summary>
            A *temporary* marker interface that for now is necessary to express enumerable result sets
            Once the concept of a result transformer is introduced we can remove the need for this extra interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledListQuery`2">
            <summary>
            A temporary marker interface that for now is necessary to express enumerable result sets
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output type</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledQuery`1">
            <summary>
            Used to express a query expression that when used will be cached by class type implementing this interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Analyze">
            <summary>
            Carry out the command and show actual run times and other statistics.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Verbose">
            <summary>
            Display additional information regarding the plan. Specifically, include the output column list for each node in the plan tree, schema-qualify table and function names, always label variables in expressions with their range table alias, and always print the name of each trigger for which statistics are displayed.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Costs">
            <summary>
            Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Buffers">
            <summary>
            Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Timing">
            <summary>
            Include the actual startup time and time spent in the node in the output.
            </summary>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable.Explain(Marten.Linq.FetchType,System.Action{Marten.Linq.IConfigureExplainExpressions})">
            <param name="configureExplain">Configure EXPLAIN options as documented in <see href="https://www.postgresql.org/docs/9.6/static/sql-explain.html">EXPLAIN documentation</see></param>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable.TransformTo``1(System.String)">
            <summary>
                Applies a pre-loaded Javascript transformation to the documents
                returned by this query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <param name="transformName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.LastModified.LastModifiedExtensions.ModifiedSince(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents modified since given time (&gt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.LastModified.LastModifiedExtensions.ModifiedBefore(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents modified before given time (&lt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.MatchesSql.MatchesSqlExtensions.MatchesSql(System.Object,Marten.Linq.IWhereFragment)">
            <summary>
            The search results should match the specified where fragment.
            </summary>
            <param name="doc"></param>
            <param name="whereFragment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.MatchesSql.MatchesSqlExtensions.MatchesSql(System.Object,System.String,System.Object[])">
            <summary>
            The search results should match the specified raw sql fragment.
            </summary>
            <param name="doc"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.IExpressionParser`1.Matches(`0)">
            <summary>
            Can this parser create a Sql where clause
            from part of a Linq expression
            </summary>
        </member>
        <member name="M:Marten.Linq.Parsing.IExpressionParser`1.Parse(Marten.Schema.IQueryableDocument,Marten.ISerializer,`0)">
            <summary>
            Creates an IWhereFragment object that Marten
            uses to help construct the underlying Sql
            command
            </summary>
        </member>
        <member name="T:Marten.Linq.Parsing.IMethodCallParser">
            <summary>
            Models the Sql generation for a method call
            in a Linq query. For example, map an expression like Where(x => x.Property.StartsWith("prefix"))
            to part of a Sql WHERE clause
            </summary>
        </member>
        <member name="M:Marten.Linq.Parsing.IMethodCallParser.Matches(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Can this parser create a Sql where clause
            from part of a Linq expression that calls
            a method
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.IMethodCallParser.Parse(Marten.Schema.IQueryableDocument,Marten.ISerializer,System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Creates an IWhereFragment object that Marten
            uses to help construct the underlying Sql
            command
            </summary>
            <param name="mapping"></param>
            <param name="serializer"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.Parsing.SimpleEqualsParser">
            <summary>
            Implement Equals for <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Decimal"/>, <see cref="T:System.Guid"/>, <see cref="T:System.Boolean"/>, <see cref="T:System.DateTime"/>, <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <remarks>Equals(object) calls into <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/>. Equals(null) is converted to "is null" query.</remarks>
        </member>
        <member name="T:Marten.Linq.Parsing.SimpleNotEqualsParser">
            <summary>
            Implement !Equals for <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Decimal"/>, <see cref="T:System.Guid"/>, <see cref="T:System.Boolean"/>, <see cref="T:System.DateTime"/>, <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <remarks>Equals(object) calls into <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/>. Equals(null) is converted to "is null" query.</remarks>
        </member>
        <member name="M:Marten.Linq.Parsing.StringComparisonParser.FormatValue(System.Reflection.MethodInfo,System.String)">
            <summary>
                Formats the string value as appropriate for the comparison.
            </summary>
            <param name="method"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.StringComparisonParser.GetOperator(System.Linq.Expressions.MethodCallExpression)">
            <summary>
                Returns the operator to emit (e.g. LIKE/ILIKE).
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.StringComparisonParser.GetLocator(Marten.Schema.IQueryableDocument,System.Linq.Expressions.MethodCallExpression)">
            <summary>
                Returns a locator for the member being queried upon
            </summary>
            <param name="mapping"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Linq.QueryPlan.NodeType">
            <summary>
            The scan type to be used to retrieve the data (ie sequential, index).
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.RelationName">
            <summary>
            The table name from which the 'select' was queried.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.Alias">
            <summary>
            The table alias that was used (if none was used, <see cref="P:Marten.Linq.QueryPlan.RelationName"/> is returned).
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.StartupCost">
            <summary>
            The cost of initialising the query.
            (note that "cost" does not have a unit - it's an arbitrary value)
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.TotalCost">
            <summary>
            The cost ofo performing the query.
            (note that "cost" does not have a unit - it's an arbitrary value)
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.PlanRows">
            <summary>
            The estimated number of rows returned.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.PlanWidth">
            <summary>
            The storage size of the query returned fields.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.Command">
            <summary>
            The command executed by Marten
            </summary>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.MaybeDeleted(System.Object)">
            <summary>
            The search results should include all documents, whether
            soft-deleted or not
            </summary>
            <typeparam name="T"></typeparam>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.IsDeleted(System.Object)">
            <summary>
            The search results should only include soft-deleted
            documents
            </summary>
            <typeparam name="T"></typeparam>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.DeletedSince(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents deleted since given time (&gt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.DeletedBefore(System.Object,System.DateTimeOffset)">
            <summary>
            The search results should include documents deleted before given time (&lt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.LinqCustomizations.MethodCallParsers">
            <summary>
                Add custom Linq expression parsers for your own methods
            </summary>
        </member>
        <member name="M:Marten.LinqExtensions.IsOneOf``1(``0,``0[])">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsOneOf``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.In``1(``0,``0[])">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.In``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Used for Linq queries to determines whether an element is a superset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Used for Linq queries to determines whether an element is a subset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Used for Linq queries to determines whether an element is a subset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Used for Linq queries to determines whether an element is a superset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Used for Linq queries to match on empty child collections
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.AnyTenant``1(``0)">
            <summary>
            Query across any and all tenants
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.TenantIsOneOf``1(``0,System.String[])">
            <summary>
            Query for the range of supplied tenants
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="tenantIds"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.Search``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="searchTerm">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.Search``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/>
            </summary>
            <param name="searchTerm">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PlainTextSearch``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PlainTextSearch``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PhraseSearch``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PhraseSearch``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="TDoc"/> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">The dictionary config passed to the 'to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.WebStyleSearch``1(``0,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="T"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.WebStyleSearch``1(``0,System.String,System.String)">
            <summary>
            Performs a full text search against <typeparamref name="T"/> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">The text to search for.  Uses an alternative syntax to the other search functions, similar to the one used by web search engines</param>
            <param name="regConfig">The dictionary config passed to the 'websearch_to_tsquery' function, must match the config parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)"/></param>
            <remarks>
            Supported from Postgres 11
            See: https://www.postgresql.org/docs/11/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="T:Marten.MartenCommandException">
            <summary>
            Wraps the Postgres command exceptions. Unifies exception handling and brings additonal information.
            </summary>
        </member>
        <member name="P:Marten.MartenCommandException.Command">
            <summary>
            Failed Postgres command
            </summary>
        </member>
        <member name="M:Marten.MartenCommandException.#ctor(Npgsql.NpgsqlCommand,System.Exception)">
            <summary>
            Creates MartenCommandException based on the command and innerException information with formatted message.
            </summary>
            <param name="command">failed Postgres command</param>
            <param name="innerException">internal exception details</param>
        </member>
        <member name="M:Marten.MartenCommandException.#ctor(Npgsql.NpgsqlCommand,System.Exception,System.String)">
            <summary>
            Creates MartenCommandException based on the command and innerException information with formatted message.
            </summary>
            <param name="command">failed Postgres command</param>
            <param name="innerException">internal exception details</param>
            <param name="prefix">prefix that will be added to message</param>
        </member>
        <member name="T:Marten.MartenRegistry">
            <summary>
            Used to customize or optimize the storage and retrieval of document types
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.For``1">
            <summary>
            Configure a single document type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.Include``1">
            <summary>
            Include the declarations from another MartenRegistry type
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.MartenRegistry.Include(Marten.MartenRegistry)">
            <summary>
            Include the declarations from another MartenRegistry object
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:Marten.MartenRegistry.DefaultIdStrategy(System.Func{Marten.Schema.IDocumentMapping,Marten.StoreOptions,Marten.Schema.Identity.IIdGeneration})">
            <summary>
            Overrides the strategy used to generate the ids.
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.PropertySearching(Marten.Schema.PropertySearching)">
            <summary>
            Specify the property searching mechanism for this document type. The default is
            JSON_Locator_Only
            </summary>
            <param name="searching"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DocumentAlias(System.String)">
            <summary>
            Override the Postgresql schema alias for this document type in order
            to disambiguate similarly named document types. The default is just
            the document type name to lower case.
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Searchable(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.IndexDefinition})">
            <summary>
            Marks a property or field on this document type as a searchable field that is also duplicated in the
            database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">Optional, allows you to customize the Postgresql database index configured for the duplicated field</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Duplicate(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.IndexDefinition},System.Boolean)">
            <summary>
            Marks a property or field on this document type as a searchable field that is also duplicated in the
            database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">Optional, allows you to customize the Postgresql database index configured for the duplicated field</param>
            <param name="dbType">Optional, overrides the Npgsql DbType for any parameter usage of this property</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Index(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
            Creates a computed index on this data member within the JSON data storage
            </summary>
            <param name="expression"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Index(System.Collections.Generic.IReadOnlyCollection{System.Linq.Expressions.Expression{System.Func{`0,System.Object}}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
            Creates a computed index on this data member within the JSON data storage
            </summary>
            <param name="expressions"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexName">Name of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="indexName">Name of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.String,Marten.Schema.Indexing.Unique.TenancyScope,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="indexTenancyStyle">Style of tenancy</param>
            <param name="indexName">Name of the index</param>
            <param name="tenancyScope">Whether the unique index applies on a per tenant basis</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IndexLastModified(System.Action{Marten.Schema.IndexDefinition})">
            <summary>
            Creates an index on the predefined Last Modified column
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.HiloSettings(Marten.Schema.Identity.Sequences.HiloSettings)">
            <summary>
            Overrides the Hilo sequence increment and "maximum low" number for document types that
            use numeric id's and the Hilo Id assignment
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DatabaseSchemaName(System.String)">
            <summary>
            Overrides the database schema name used to store the documents.
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IdStrategy(Marten.Schema.Identity.IIdGeneration)">
            <summary>
            Overrides the stragtegy used for id generation.
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.GinIndexJsonData(System.Action{Marten.Schema.IndexDefinition})">
            <summary>
            Adds a Postgresql Gin index to the JSONB data column for this document type. Leads to faster
            querying, but does add overhead to storage and database writes
            </summary>
            <param name="configureIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClass(System.Type,System.String)">
            <summary>
            Programmatically directs Marten to map this type to a hierarchy of types
            </summary>
            <param name="subclassType"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClassHierarchy(Marten.MappedType[])">
            <summary>
            Programmatically directs Marten to map all the subclasses of <cref name="T"/> to a hierarchy of types
            </summary>
            <param name="allSubclassTypes">All the subclass types of <cref name="T"/> that you wish to map.
            You can use either params of <see cref="T:System.Type"/> or <see cref="T:Marten.MappedType"/> or a mix, since Type can implicitly convert to MappedType (without an alias)</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClassHierarchy">
            <summary>
            Programmatically directs Marten to map all the subclasses of <cref name="T"/> to a hierarchy of types. <c>Unadvised in projects with many types.</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UseOptimisticConcurrency(System.Boolean)">
            <summary>
            Directs Marten to use the optimistic versioning checks upon updates
            to this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.SoftDeleted">
            <summary>
            Directs Marten to apply "soft deletes" to this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DdlTemplate(System.String)">
            <summary>
            Direct this document type's DDL to be created with the named template
            </summary>
            <param name="templateName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.MultiTenanted">
            <summary>
            Marks just this document type as being stored with conjoined multi-tenancy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UseIdentityKey">
            <summary>
            Opt into the identity key generation strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)">
            <summary>
            Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
            to your application with the given Postgresql connection string and Marten
            defaults
            </summary>
            <param name="services"></param>
            <param name="connectionString">The connection string to your application's Postgresql database</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,Marten.StoreOptions)">
            <summary>
            Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
            to your application using the configured StoreOptions
            </summary>
            <param name="services"></param>
            <param name="options">The Marten configuration for this application</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Marten.StoreOptions})">
            <summary>
            Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
            to your application using the configured StoreOptions
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.BuildSessionsWith``1">
            <summary>
            Use an alternative strategy / configuration for opening IDocumentSession or IQuerySession
            objects in the application with a custom ISessionFactory type registered as a singleton
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.BuildSessionsPerScopeWith``1">
             <summary>
             Use an alternative strategy / configuration for opening IDocumentSession or IQuerySession
             objects in the application with a custom ISessionFactory type registered as scoped.
            
             Use this overload if the session creation needs to vary by application scope such as
             using a different tenant per HTTP request or if using some kind of scoped logging
             </summary>
             <typeparam name="T"></typeparam>
             <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.InitializeStore">
            <summary>
            Eagerly build the application's DocumentStore during application
            bootstrapping rather than waiting for the first usage of IDocumentStore
            at runtime.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.ISessionFactory">
            <summary>
            Pluggable strategy for customizing how IDocumentSession / IQuerySession
            objects are created within an application.
            </summary>
        </member>
        <member name="T:Marten.Pagination.IPagedList`1">
            <summary>
            Interface for paged list
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.Item(System.Int32)">
            <summary>
            Return the paged query result
            </summary>
            <param name="index">Index to fetch item from paged query result</param>
            <returns>/returns item from paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.Count">
            <summary>
            Return the number of records in the paged query result
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageNumber">
            <summary>
            Gets current page number
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageSize">
            <summary>
            Gets page size
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageCount">
            <summary>
            Gets number of pages
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.TotalItemCount">
            <summary>
            Gets the total number records
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.HasPreviousPage">
            <summary>
            Gets a value indicating whether there is a previous page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.HasNextPage">
            <summary>
            Gets a value indicating whether there is next page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.IsFirstPage">
            <summary>
            Gets a value indicating whether the current page is first page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.IsLastPage">
            <summary>
            Gets a value indicating whether the current page is last page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.FirstItemOnPage">
            <summary>
            Gets one-based index of first item in current page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.LastItemOnPage">
            <summary>
            Gets one-based index of last item in current page
            </summary>
        </member>
        <member name="T:Marten.Pagination.PagedList`1">
            <summary>
            Class to return The async paged list from a paged query.
            </summary>
            <typeparam name="T">Document Type</typeparam>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.Item(System.Int32)">
            <summary>
            Return the paged query result
            </summary>
            <param name="index">Index to fetch item from paged query result</param>
            <returns>/returns item from paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.Count">
            <summary>
            Return the number of records in the paged query result
            </summary>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.GetEnumerator">
            <summary>
            Generic Enumerator
            </summary>
            <returns>Generic Enumerator of paged query result</returns>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerator
            </summary>
            <returns>Enumerator of paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageNumber">
            <summary>
            Gets current page number
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageSize">
            <summary>
            Gets page size
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageCount">
            <summary>
            Gets number of pages
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.TotalItemCount">
            <summary>
            Gets the total number records
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.HasPreviousPage">
            <summary>
            Gets a value indicating whether there is a previous page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.HasNextPage">
            <summary>
            Gets a value indicating whether there is next page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.IsFirstPage">
            <summary>
            Gets a value indicating whether the current page is first page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.IsLastPage">
            <summary>
            Gets a value indicating whether the current page is last page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.FirstItemOnPage">
            <summary>
            Gets one-based index of first item in current page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.LastItemOnPage">
            <summary>
            Gets one-based index of last item in current page
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.Pagination.PagedList`1.CreateAsync(System.Linq.IQueryable{`0},System.Int32,System.Int32)" -->
        <member name="M:Marten.Pagination.PagedList`1.InitAsync(System.Linq.IQueryable{`0},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Marten.Pagination.PagedList`1" /> class.
            </summary>
            <param name="queryable">Query for which data has to be fetched</param>
            <param name="pageSize">Page size</param>
            <param name="totalItemCount">Total count of all records</param>
        </member>
        <member name="T:Marten.Pagination.PagedListQueryableExtensions">
            <summary>
            Extension methods on <see cref="T:Marten.Linq.IMartenQueryable`1"/> for performing paged queries
            </summary>
        </member>
        <member name="M:Marten.Pagination.PagedListQueryableExtensions.ToPagedList``1(System.Linq.IQueryable{``0},System.Int32,System.Int32)">
            <summary>
            Extension method to return a paged results
            </summary>
            <typeparam name="T">Document Type</typeparam>
            <param name="queryable">Extension point on <see cref="T:System.Linq.IQueryable`1"/></param>
            <param name="pageNumber">one based page number</param>
            <param name="pageSize">Page size</param>
            <returns>return paged result</returns>
        </member>
        <member name="M:Marten.Pagination.PagedListQueryableExtensions.ToPagedListAsync``1(System.Linq.IQueryable{``0},System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Async Extension method to return a paged results
            </summary>
            <typeparam name="T">Document Type</typeparam>
            <param name="queryable">Extension point on <see cref="T:System.Linq.IQueryable`1"/></param>
            <param name="pageNumber">One based page number</param>
            <param name="pageSize">Page size</param>
            <param name="token">Cancellation token</param>
            <returns>return paged result</returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Set``1(System.String,``0)">
            <summary>
            Set a single field or property value within the persisted JSON data
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Set``2(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},``1)">
            <summary>
            Set a single field or property value within the persisted JSON data
            </summary>
            <typeparam name="TParent"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="name"></param>
            <param name="expression">Path to the parent location</param>
            <param name="value"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Set a single field or property value within the persisted JSON data
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="expression"></param>
            <param name="value"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Duplicate``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``0}}[])">
            <summary>
            Copy a single field or property value within the persisted JSON data to one or more destinations
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="destinations"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Int32}},System.Int32)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Int64}},System.Int64)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Double}},System.Double)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Single}},System.Single)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Append``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0)">
            <summary>
            Append an element to the end of a child collection on the persisted
            document
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.AppendIfNotExists``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0)">
            <summary>
            Append an element to the end of a child collection on the persisted
            document if the element does not already exist
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Insert``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0,System.Int32)">
            <summary>
            Insert an element at the designated index to a child collection on the persisted document
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <param name="index"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.InsertIfNotExists``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0,System.Int32)">
            <summary>
            Insert an element at the designated index to a child collection on the persisted document
            if the value does not already exist at that index
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <param name="index"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Remove``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0,Marten.Patching.RemoveAction)">
            <summary>
            Remove element from a child collection on the persisted document
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <param name="action"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Rename(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Rename a property or field in the persisted JSON document
            </summary>
            <param name="oldName"></param>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Delete(System.String)">
            <summary>
            Delete a removed property or field in the persisted JSON data
            </summary>
            <param name="name">Redundant property or field name</param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Delete``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Delete a removed property or field in the persisted JSON data
            </summary>
            <typeparam name="TParent"></typeparam>
            <param name="name">Redundant property or field name</param>
            <param name="expression">Path to the parent location</param>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Delete``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Delete an existing property or field in the persisted JSON data
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression">Path to the property or field to delete</param>
        </member>
        <member name="F:Marten.SecurityRights.Invoker">
            <summary>
            Upsert functions will execute with the rights of the current Postgresql user. This is the default
            in both Marten and Postgresql.
            </summary>
        </member>
        <member name="F:Marten.SecurityRights.Definer">
            <summary>
            Upsert functions will execute with the rights of the Postgresql user that created the schema
            objects.
            </summary>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Count">
            <summary>
            Return a count of all the documents of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Return a count of all the documents of type "T" that match the query
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Any">
            <summary>
            Where for the existence of any documents of type "T" matching the query
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Any(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Where for the existence of any documents of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.First(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Find the first document of type "T" matching this query. Will throw an exception if there are no matching documents
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.FirstOrDefault">
            <summary>
            Find the first document of type "T" that matches the query. Will return null if no documents match.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Single">
            <summary>
            Returns the single document of type "T" matching this query. Will
            throw an exception if the results are null or contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Single(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Returns the single document of type "T" matching this query. Will
            throw an exception if the results are null or contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.SingleOrDefault">
            <summary>
            Returns the single document of type "T" matching this query or null. Will
            throw an exception if the results contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.SingleOrDefault(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Returns the single document of type "T" matching this query or null. Will
            throw an exception if the results contain more than one
            document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.AggregateStream``1(System.Guid,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Fetch a live aggregation of a single event stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamId"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.Load(System.Guid)">
            <summary>
            Load a single event with all of its metadata
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStreamState(System.Guid)">
            <summary>
            Load the high level metadata about a single event stream
            </summary>
            <param name="streamId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStream(System.Guid,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Fetch all the events for a single event stream
            </summary>
            <param name="streamId"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Services.BatchQuerying.IBatchedQuery.Events">
            <summary>
            Access to event store specific query mechanisms
            </summary>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.String)">
            <summary>
            Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.ValueType)">
            <summary>
            Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.LoadMany``1">
            <summary>
            Load a one or more documents of Type "T" by id's
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``1(System.String,System.Object[])">
            <summary>
            Execute a user provided query against "T"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Execute(System.Threading.CancellationToken)">
            <summary>
            Execute this batched query
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``1">
            <summary>
            Where for documents of type "T" by Linq expression
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Execute a compiled query as part of the batch query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.Services.CommandRunnerMode.External">
            <summary>
            Implies that some other process is controlling the transaction boundaries
            </summary>
        </member>
        <member name="M:Marten.Services.Diagnostics.PreviewCommand``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Preview the database command that will be executed for this compiled query
            object
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.Diagnostics.ExplainPlan``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
            Find the Postgresql EXPLAIN PLAN for this compiled query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.Diagnostics.GetPostgresVersion">
            <summary>
            Method to fetch Postgres server version
            </summary>
            <returns>Returns version</returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Deletions">
            <summary>
            All of the pending deletions that will be processed
            when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.DeletionsFor``1">
            <summary>
            All the pending deletions of documents of type T that will be processed
            when this session is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.DeletionsFor(System.Type)">
            <summary>
            All the pending deletions of documents of type documentType that will be processed
            when this session is committed
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Updates">
            <summary>
            All the documents that will be updated when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Inserts">
            <summary>
            All of the documents that will be inserted when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.UpdatesFor``1">
            <summary>
            All the documents of type T that will be updated when this session is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.InsertsFor``1">
            <summary>
            All the documents of type T that will be inserted when this session is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.AllChangedFor``1">
            <summary>
            All of the documents of type T that will be inserted or updated when this session
            is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Streams">
            <summary>
            All of the pending events for the event store in this unit of work
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Patches">
            <summary>
            All of the pending patch operations in this unit of work
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Operations">
            <summary>
            All the storage operations that will be executed when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.OperationsFor``1">
            <summary>
            All the storage operations that will be executed for documents of type T when this
            session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.OperationsFor(System.Type)">
            <summary>
            All the storage operations that will be executed for documents of type T when this
            session is committed
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Services.Json.JsonNetCollectionToArrayJsonConverter">
            <summary>
            Serialize collection type property to JSON array using a custom Newtonsoft.Json JsonConverter
            Note that without using custom `JsonConverter`, `Newtonsoft.Json` stores it as $type and $value.
            Or you may need to resort to `Newtonsoft.Json.TypeNameHandling.None` which has its own side-effects
            </summary>
        </member>
        <member name="M:Marten.Services.JsonNetSerializer.Customize(System.Action{Newtonsoft.Json.JsonSerializer})">
            <summary>
            Customize the inner Newtonsoft formatter.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.EnumStorage">
            <summary>
            Specify whether .Net Enum values should be stored as integers or strings
            within the Json document. Default is AsInteger.
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.Casing">
            <summary>
            Specify whether properties in the JSON document should use Camel or Pascal casing.
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.CollectionStorage">
            <summary>
            Specify whether collections should be stored as json arrays (without type names)
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.NonPublicMembersStorage">
            <summary>
            Specify whether non public members should be used during deserialization
            </summary>
        </member>
        <member name="T:Marten.Services.NoDataReturnedCall">
            <summary>
            Marker interface telling Marten not
            to advance the results for callbacks
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Tracking">
            <summary>
            Default to DocumentTracking.IdentityOnly
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Timeout">
            <summary>
            If not specified, sessions default to Npgsql command timeout (30 seconds)
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.IsolationLevel">
            <summary>
            Default to IsolationLevel.ReadCommitted
            </summary>
        </member>
        <member name="F:Marten.Services.SessionOptions.Listeners">
            <summary>
                Add, remove, or reorder local session listeners
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.TenantId">
            <summary>
            Override the tenant id for the requested session
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.ConcurrencyChecks">
            <summary>
            Use to enable or disable optimistic concurrency for just this session
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Connection">
            <summary>
            Optional mechanism to open a session with an existing connection
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Transaction">
            <summary>
            Optional mechanism to open a session with an existing transaction
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.OwnsTransactionLifecycle">
            <summary>
            Default is true. If false, Marten will issue commands on IDocumentSession.SaveChanges/SaveChangesAsync,
            but will **not** commit the transaction
            </summary>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForTransaction(Npgsql.NpgsqlTransaction)">
            <summary>
            Enlist in the native Npgsql transaction and direct the session
            *not* to own the transactional lifecycle
            </summary>
            <param name="transaction"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Services.SessionOptions.EnlistInAmbientTransactionScope">
            <summary>
            Enlist the session in the current, ambient transaction scope
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.DotNetTransaction">
            <summary>
            Enlist the session in this transaction
            </summary>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForCurrentTransaction">
            <summary>
            Open a session that enlists in the current, ambient TransactionScope
            </summary>
            <returns></returns>
        </member>
        <member name="F:Marten.Services.ConcurrencyChecks.Enabled">
            <summary>
            Optimistic concurrency checks are enforced (Default)
            </summary>
        </member>
        <member name="F:Marten.Services.ConcurrencyChecks.Disabled">
            <summary>
            Optimistic concurrency checks are disabled for this session
            </summary>
        </member>
        <member name="T:Marten.SortOrder">
            <summary>
            Specifies the direction used to sort items
            </summary>
        </member>
        <member name="F:Marten.SortOrder.Asc">
            <summary>
            Sorts in ascending order, from smallest to largest
            </summary>
        </member>
        <member name="F:Marten.SortOrder.Desc">
            <summary>
            Sorts in descending order, from largest to smallest
            </summary>
        </member>
        <member name="T:Marten.Storage.Function">
            <summary>
            Base class for an ISchemaObject manager for a Postgresql function
            </summary>
        </member>
        <member name="M:Marten.Storage.Function.Write(Marten.DdlRules,System.IO.StringWriter)">
            <summary>
            Override to write the actual DDL code
            </summary>
            <param name="rules"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Marten.Storage.Function.toDropSql">
            <summary>
            Override to customize the DROP statements for this function
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.Storage.IFeatureSchema">
            <summary>
            Defines the database objects for a named feature within your
            Marten application
            </summary>
        </member>
        <member name="M:Marten.Storage.IFeatureSchema.DependentTypes">
            <summary>
            Any document or feature types that this feature depends on. Used
            to intelligently order the creation and scripting of database
            schema objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IFeatureSchema.IsActive(Marten.StoreOptions)">
            <summary>
            Should this feature be active based on the current options?
            </summary>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Storage.IFeatureSchema.Objects">
            <summary>
            All the schema objects in this feature
            </summary>
        </member>
        <member name="P:Marten.Storage.IFeatureSchema.StorageType">
            <summary>
            Identifier by type for this feature. Used along with the DependentTypes()
            collection to control the proper ordering of object creation or scripting
            </summary>
        </member>
        <member name="P:Marten.Storage.IFeatureSchema.Identifier">
            <summary>
            Really just the filename when the SQL is exported
            </summary>
        </member>
        <member name="M:Marten.Storage.IFeatureSchema.WritePermissions(Marten.DdlRules,System.IO.StringWriter)">
            <summary>
            Write any permission SQL when this feature is exported to a SQL
            file
            </summary>
            <param name="rules"></param>
            <param name="writer"></param>
        </member>
        <member name="T:Marten.Storage.FeatureSchemaBase">
            <summary>
            Base class for easier creation of custom IFeatureSchema objects
            </summary>
        </member>
        <member name="P:Marten.Storage.ITenant.DbObjects">
            <summary>
                Query against the actual Postgresql database schema objects
            </summary>
        </member>
        <member name="M:Marten.Storage.ITenant.StorageFor(System.Type)">
            <summary>
            Retrieves or generates the active IDocumentStorage object
            for the given document type
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.MappingFor(System.Type)">
            <summary>
            Finds or creates the IDocumentMapping for a document type
            that governs how that document type is persisted and queried
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.EnsureStorageExists(System.Type)">
            <summary>
            Ensures that the IDocumentStorage object for a document type is ready
            and also attempts to update the database schema for any detected changes
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="P:Marten.Storage.ITenant.Sequences">
            <summary>
            Used to create new Hilo sequences
            </summary>
        </member>
        <member name="M:Marten.Storage.ITenant.ResetSchemaExistenceChecks">
            <summary>
            Directs Marten to disregard any previous schema checks. Useful
            if you change the underlying schema without shutting down the document store
            </summary>
        </member>
        <member name="M:Marten.Storage.ITenant.BulkLoaderFor``1">
            <summary>
            Retrieve a configured IBulkLoader for a document type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.OpenConnection(Marten.Services.CommandRunnerMode,System.Data.IsolationLevel,System.Nullable{System.Int32})">
            <summary>
                Directly open a managed connection to the underlying Postgresql database
            </summary>
            <param name="mode"></param>
            <param name="isolationLevel"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.ResetHiloSequenceFloor``1(System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="M:Marten.Storage.ITenant.MetadataFor``1(``0)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.MetadataForAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenant.CreateConnection">
            <summary>
            Fetch a connection to the tenant database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.Add(Marten.Storage.IFeatureSchema)">
            <summary>
            Register custom storage features
            </summary>
            <param name="feature"></param>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.Add``1">
            <summary>
            Register custom storage features by type. Type must have either a no-arg, public
            constructor or a constructor that takes in a single StoreOptions parameter
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Storage.Table">
            <summary>
            Model a database table in Postgresql
            </summary>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Single">
            <summary>
            No multi-tenancy, the default mode
            </summary>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Conjoined">
            <summary>
            Multi-tenanted within the same database/schema through a tenant id
            </summary>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Separate">
            <summary>
            Multi-tenanted through separate databases or schemas
            </summary>
        </member>
        <member name="M:Marten.Storage.Tenant.OpenConnection(Marten.Services.CommandRunnerMode,System.Data.IsolationLevel,System.Nullable{System.Int32})">
            <summary>
                Directly open a managed connection to the underlying Postgresql database
            </summary>
            <param name="mode"></param>
            <param name="isolationLevel"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.Tenant.CreateConnection">
            <summary>
            Fetch a connection to the tenant database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.Tenant.ResetHiloSequenceFloor``1(System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="M:Marten.Storage.Tenant.MetadataFor``1(``0)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.Tenant.MetadataForAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.StoreOptions">
            <summary>
                StoreOptions supplies all the necessary configuration
                necessary to customize and bootstrap a working
                DocumentStore
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.DefaultDatabaseSchemaName">
            <summary>
                The default database schema used 'public'.
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.Listeners">
            <summary>
                Add, remove, or reorder global session listeners
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.Schema">
            <summary>
                Modify the document and event store database mappings for indexes and searching options
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.AutoCreateSchemaObjects">
            <summary>
                Whether or Marten should attempt to create any missing database schema objects at runtime. This
                property is "All" by default for more efficient development, but can be set to lower values for production usage.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.StoreOptions.CreateDatabasesForTenants(System.Action{Marten.Schema.IDatabaseCreationExpressions})" -->
        <member name="P:Marten.StoreOptions.DatabaseSchemaName">
            <summary>
                Sets the database default schema name used to store the documents.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.HiloSequenceDefaults">
            <summary>
                Global default parameters for Hilo sequences within the DocumentStore. Can be overridden per document
                type as well
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.UpdateBatchSize">
            <summary>
                Sets the batch size for updating or deleting documents in IDocumentSession.SaveChanges() /
                IUnitOfWork.ApplyChanges()
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.UseCharBufferPooling">
            <summary>
                Configures the store to use char buffer pooling, greatly reducing allocations for serializing documents and events.
                The default is true.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DefaultIdStrategy">
            <summary>
                Set the default Id strategy for the document mapping.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Events">
            <summary>
                Configuration of event streams and projections
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Linq">
            <summary>
                Extension point to add custom Linq query parsers
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DdlRules">
            <summary>
                Allows you to modify how the DDL for document tables and upsert functions is
                written
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.NameDataLength">
            <summary>
                Used to validate database object name lengths against Postgresql's NAMEDATALEN property to avoid
                Marten getting confused when comparing database schemas against the configuration. See
                https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html
                for more information. This does NOT adjust NAMEDATALEN for you.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.EnumStorage">
            <summary>
                Gets Enum values stored as either integers or strings
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DuplicatedFieldEnumStorage">
            <summary>
                Sets Enum values stored as either integers or strings for DuplicatedField.
                Please use only for migration from Marten 2.*. It might be removed in the next major version.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime">
            <summary>
                Decides if `timestamp without time zone` database type should be used for `DateTime` DuplicatedField.
                Please use only for migration from Marten 2.*. It might be removed in the next major version.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.UseTransactionIdFixToAvoidEventLossInProjectionDaemon">
            <summary>
            Ensures the projection daemon runs without event loss.
            Requires db migrations for existing databases.
            See https://github.com/JasperFx/marten/pull/1880 for details
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.String)">
            <summary>
                Supply the connection string to the Postgresql database
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.Func{System.String})">
            <summary>
                Supply a source for the connection string to a Postgresql database
            </summary>
            <param name="connectionSource"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.Func{Npgsql.NpgsqlConnection})">
            <summary>
                Supply a mechanism for resolving an NpgsqlConnection object to
                the Postgresql database
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Marten.StoreOptions.Serializer(Marten.ISerializer)">
            <summary>
                Override the JSON serialization by ISerializer type
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Marten.StoreOptions.UseDefaultSerialization(Marten.EnumStorage,Marten.Casing,Marten.CollectionStorage,Marten.NonPublicMembersStorage)">
            <summary>
                Use the default serialization (ilmerged Newtonsoft.Json) with Enum values
                stored as either integers or strings
            </summary>
            <param name="enumStorage"></param>
            <param name="casing">Casing style to be used in serialization</param>
            <param name="collectionStorage">Allow to set collection storage as raw arrays (without explicit types)</param>
            <param name="nonPublicMembersStorage">Allow non public members to be used during deserialization</param>
        </member>
        <member name="M:Marten.StoreOptions.Serializer``1">
            <summary>
                Override the JSON serialization by an ISerializer of type "T"
            </summary>
            <typeparam name="T">The ISerializer type</typeparam>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentType``1">
            <summary>
                Force Marten to create document mappings for type T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentType(System.Type)">
            <summary>
                Force Marten to create a document mapping for the document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
                Force Marten to create document mappings for all the given document types
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.StoreOptions.Validate">
            <summary>
            Validate that minimal options to initialize a document store have been specified
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Policies">
            <summary>
            Apply conventional policies to how documents are mapped
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DefaultTenantUsageEnabled">
            <summary>
            Option to enable or disable usage of default tenant when using multi-tenanted documents
            </summary>
        </member>
        <member name="M:Marten.Transforms.IDocumentTransforms.All``1(System.String)">
            <summary>
            Apply the named transform to all documents of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="transformName"></param>
        </member>
        <member name="M:Marten.Transforms.IDocumentTransforms.Where``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Apply the named transform to documents of type T
            matching the supplied "where" clause
            </summary>
            <typeparam name="T"></typeparam>
            <param name="transformName"></param>
            <param name="where"></param>
        </member>
        <member name="M:Marten.Transforms.IDocumentTransforms.Tenant``1(System.String,System.String)">
            <summary>
            Apply the named transform to only the specified tenant
            </summary>
            <typeparam name="T"></typeparam>
            <param name="transformName"></param>
            <param name="tenantId"></param>
        </member>
        <member name="M:Marten.Transforms.IDocumentTransforms.Tenants``1(System.String,System.String[])">
            <summary>
            Apply the named transform to only the specified tenants
            </summary>
            <typeparam name="T"></typeparam>
            <param name="transformName"></param>
            <param name="tenantIds"></param>
        </member>
        <member name="M:Marten.Transforms.TransformExtensions.TransformToJson``1(``0,System.String)">
            <summary>
                Placeholder for Linq expressions
            </summary>
            <typeparam name="T"></typeparam>
            <param name="doc"></param>
            <param name="transformName"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Util.ExpressionCompiler">
            <summary>Compiles expression to delegate by emitting the IL directly.
            The emitter is ~20 times faster than Expression.Compile.</summary>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.Compile``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>First tries to compile fast and if failed (null result), then falls back to Expression.Compile.</summary>
            <typeparam name="T">Type of compiled delegate return result.</typeparam>
            <param name="lambdaExpr">Expr to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.Compile``1(System.Linq.Expressions.LambdaExpression)">
            <summary>Compiles lambda expression to <typeparamref name="TDelegate"/>.</summary>
            <typeparam name="TDelegate">The compatible delegate type, otherwise case will throw.</typeparam>
            <param name="lambdaExpr">Lambda expression to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.LambdaExpression)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/>.</summary>
            <typeparam name="TDelegate">The compatible delegate type, otherwise case will throw.</typeparam>
            <param name="lambdaExpr">Lambda expression to compile.</param>
            <returns>Compiled delegate.</returns>
        </member>
        <member name="M:Marten.Util.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Type[],System.Type)">
            <summary>Compiles expression to delegate by emitting the IL.
            If sub-expressions are not supported by emitter, then the method returns null.
            The usage should be calling the method, if result is null then calling the Expression.Compile.</summary>
            <param name="bodyExpr">Lambda body.</param>
            <param name="paramExprs">Lambda parameter expressions.</param>
            <param name="paramTypes">The types of parameters.</param>
            <param name="returnType">The return type.</param>
            <returns>Result delegate or null, if unable to compile.</returns>
        </member>
        <member name="T:Marten.Util.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:Marten.Util.ExpressionCompiler.EmittingVisitor.TryEmit(System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Reflection.Emit.ILGenerator,Marten.Util.ExpressionCompiler.ClosureInfo)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
        <member name="T:Marten.Util.Fun">
            <summary>Helpers for functional composition</summary>
        </member>
        <member name="M:Marten.Util.Fun.It``1(``0)">
            <summary>Identity function returning passed argument as result.</summary>
        </member>
        <member name="M:Marten.Util.Fun.Do``2(``0,System.Func{``0,``1})">
            <summary>Forward pipe operator to combine multiple actions.</summary>
        </member>
        <member name="M:Marten.Util.Fun.Do``1(``0,System.Action{``0})">
            <summary>Forward pipe operator to combine multiple actions.</summary>
        </member>
        <member name="T:Marten.Util.ArrayTools">
            <summary>Methods to work with immutable arrays, and general array sugar.</summary>
        </member>
        <member name="M:Marten.Util.ArrayTools.Empty``1">
            <summary>Returns singleton empty array of provided type.</summary>
            <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.One``1(``0)">
            <summary>Wraps item in array.</summary>
        </member>
        <member name="M:Marten.Util.ArrayTools.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.EmptyIfNull``1(``0[])">
            <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        </member>
        <member name="M:Marten.Util.ArrayTools.ToArrayOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns source enumerable if it is array, otherwise converts source to array.</summary>
        </member>
        <member name="M:Marten.Util.ArrayTools.Append``1(``0[],``0[])">
            <summary>Returns new array consisting from all items from source array then all items from added array.
            If source is null or empty, then added array will be returned.
            If added is null or empty, then source will be returned.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array with leading items.</param>
            <param name="added">Array with following items.</param>
            <returns>New array with items of source and added arrays.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Performant concat of enumerables in case of arrays.
            But performance will degrade if you use Concat().Where().</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="source">goes first.</param>
            <param name="other">appended to source.</param>
            <returns>empty array or concat of source and other.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.AppendOrUpdate``1(``0[],``0,System.Int32)">
            <summary>Returns new array with <paramref name="value"/> appended,
            or <paramref name="value"/> at <paramref name="index"/>, if specified.
            If source array could be null or empty, then single value item array will be created despite any index.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array to append value to.</param>
            <param name="value">Value to append.</param>
            <param name="index">(optional) Index of value to update.</param>
            <returns>New array with appended or updated value.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.IndexOf``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
            then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
            <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.IndexOf``1(``0[],``0)">
            <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="value">Value to look up.</param>
            <returns>Index of item equal to value, or -1 item is not found.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.RemoveAt``1(``0[],System.Int32)">
            <summary>Produces new array without item at specified <paramref name="index"/>.
            Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
            <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Remove``1(``0[],``0)">
            <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
            <returns>New array with value removed or original array if value is not found.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.FindFirst``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.FindFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Match``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>New array if some items are filter out. Empty array if all items are filtered out. Original array otherwise.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Match``2(``0[],System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param> <param name="map">Converter from source to result item.</param>
            <returns>New array of result items.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Map``2(``0[],System.Func{``0,``1})">
            <summary>Maps all items from source to result array.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Maps all items from source to result collection.
            If possible uses fast array Map otherwise Enumerable.Select.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Match``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="M:Marten.Util.ArrayTools.Match``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array,
            otherwise just calls Where, Select</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="T:Marten.Util.Ref`1">
            <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="M:Marten.Util.Ref.Swap``1(``0@,System.Func{``0,``0})"/>.</summary>
            <typeparam name="T">Type of object to wrap.</typeparam>
        </member>
        <member name="P:Marten.Util.Ref`1.Value">
            <summary>Gets the wrapped value.</summary>
        </member>
        <member name="M:Marten.Util.Ref`1.#ctor(`0)">
            <summary>Creates ref to object, optionally with initial value provided.</summary>
            <param name="initialValue">(optional) Initial value.</param>
        </member>
        <member name="M:Marten.Util.Ref`1.Swap(System.Func{`0,`0})">
            <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="M:Marten.Util.Ref.Swap``1(``0@,System.Func{``0,``0})"/> for details.</summary>
            <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:Marten.Util.Ref`1.Swap(`0)">
            <summary>Just sets new value ignoring any intermingled changes.</summary>
            <param name="newValue"></param> <returns>old value</returns>
        </member>
        <member name="M:Marten.Util.Ref`1.TrySwapIfStillCurrent(`0,`0)">
            <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
            <param name="currentValue"></param> <param name="newValue"></param>
            <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
            <example><c>[!CDATA[
            var value = SomeRef.Value;
            if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
                SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
            ]]</c></example>
        </member>
        <member name="T:Marten.Util.Ref">
            <summary>Provides optimistic-concurrency consistent <see cref="M:Marten.Util.Ref.Swap``1(``0@,System.Func{``0,``0})"/> operation.</summary>
        </member>
        <member name="M:Marten.Util.Ref.Of``1(``0)">
            <summary>Factory for <see cref="T:Marten.Util.Ref`1"/> with type of value inference.</summary>
            <typeparam name="T">Type of value to wrap.</typeparam>
            <param name="value">Initial value to wrap.</param>
            <returns>New ref.</returns>
        </member>
        <member name="M:Marten.Util.Ref.NewRef``1(Marten.Util.Ref{``0})">
            <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
            <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        </member>
        <member name="M:Marten.Util.Ref.Swap``1(``0@,System.Func{``0,``0})">
            <summary>First, it evaluates new value using <paramref name="getNewValue"/> function.
            Second, it checks that original value is not changed.
            If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
            <typeparam name="T">Type of value to swap.</typeparam>
            <param name="value">Reference to change to new value</param>
            <param name="getNewValue">Delegate to get value from old one.</param>
            <returns>Old/original value. By analogy with <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/>.</returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="T:Marten.Util.KV`2">
            <summary>Immutable Key-Value pair. It is reference type (could be check for null),
            which is different from System value type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            In addition provides <see cref="M:Marten.Util.KV`2.Equals(System.Object)"/> and <see cref="M:Marten.Util.KV`2.GetHashCode"/> implementations.</summary>
            <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
        </member>
        <member name="F:Marten.Util.KV`2.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:Marten.Util.KV`2.Value">
            <summary>Value.</summary>
        </member>
        <member name="M:Marten.Util.KV`2.#ctor(`0,`1)">
            <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
            <param name="key">key.</param><param name="value">value.</param>
        </member>
        <member name="M:Marten.Util.KV`2.ToString">
            <summary>Creates nice string view.</summary><returns>String representation.</returns>
        </member>
        <member name="M:Marten.Util.KV`2.Equals(System.Object)">
            <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
            <param name="obj">Object to check equality with.</param> <returns>True if equal.</returns>
        </member>
        <member name="M:Marten.Util.KV`2.GetHashCode">
            <summary>Combines key and value hash code. R# generated default implementation.</summary>
            <returns>Combined hash code for key-value.</returns>
        </member>
        <member name="T:Marten.Util.KV">
            <summary>Helpers for <see cref="T:Marten.Util.KV`2"/>.</summary>
        </member>
        <member name="M:Marten.Util.KV.Of``2(``0,``1)">
            <summary>Creates the key value pair.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="key">Key</param> <param name="value">Value</param> <returns>New pair.</returns>
        </member>
        <member name="M:Marten.Util.KV.WithKey``2(Marten.Util.KV{``0,``1},``0)">
            <summary>Creates the new pair with new key and old value.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="source">Source value</param> <param name="key">New key</param> <returns>New pair</returns>
        </member>
        <member name="M:Marten.Util.KV.WithValue``2(Marten.Util.KV{``0,``1},``1)">
            <summary>Creates the new pair with old key and new value.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="source">Source value</param> <param name="value">New value.</param> <returns>New pair</returns>
        </member>
        <member name="T:Marten.Util.KeyValuePair">
            <summary>Simple helper for creation of the pair of two parts.</summary>
        </member>
        <member name="M:Marten.Util.KeyValuePair.Pair``2(``0,``1)">
            <summary>Pairs key with value.</summary>
        </member>
        <member name="T:Marten.Util.Opt`1">
            <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
        </member>
        <member name="M:Marten.Util.Opt`1.op_Implicit(`0)~Marten.Util.Opt{`0}">
            <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        </member>
        <member name="F:Marten.Util.Opt`1.Value">
            <summary>Argument value.</summary>
        </member>
        <member name="F:Marten.Util.Opt`1.HasValue">
            <summary>Indicates that value is provided.</summary>
        </member>
        <member name="M:Marten.Util.Opt`1.#ctor(`0)">
            <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        </member>
        <member name="M:Marten.Util.Opt`1.OrDefault(`0)">
            <summary>Helper to get value or default value if value is not present.</summary>
        </member>
        <member name="T:Marten.Util.ImList`1">
            <summary>Immutable list - simplest linked list with Head and Rest.</summary>
            <typeparam name="T">Type of the item.</typeparam>
        </member>
        <member name="F:Marten.Util.ImList`1.Empty">
            <summary>Empty list to Push to.</summary>
        </member>
        <member name="P:Marten.Util.ImList`1.IsEmpty">
            <summary>True for empty list.</summary>
        </member>
        <member name="F:Marten.Util.ImList`1.Head">
            <summary>First value in a list.</summary>
        </member>
        <member name="F:Marten.Util.ImList`1.Tail">
            <summary>The rest of values or Empty if list has a single value.</summary>
        </member>
        <member name="M:Marten.Util.ImList`1.Prep(`0)">
            <summary>Prepends new value and returns new list.</summary>
            <param name="head">New first value.</param>
            <returns>List with the new head.</returns>
        </member>
        <member name="M:Marten.Util.ImList`1.Enumerate">
            <summary>Enumerates the list.</summary>
            <returns>Each item in turn.</returns>
        </member>
        <member name="T:Marten.Util.ImList">
            <summary>Extension methods providing basic operations on a list.</summary>
        </member>
        <member name="M:Marten.Util.ImList.To``2(Marten.Util.ImList{``0},``1,System.Func{``0,``1,``1})">
            <summary>This a basically a Fold function, to address needs in Map, Filter, Reduce.</summary>
            <typeparam name="T">Type of list item.</typeparam>
            <typeparam name="R">Type of result.</typeparam>
            <param name="source">List to fold.</param>
            <param name="initialValue">From were to start.</param>
            <param name="collect">Collects list item into result</param>
            <returns>Return result or <paramref name="initialValue"/> for empty list.</returns>
        </member>
        <member name="M:Marten.Util.ImList.To``2(Marten.Util.ImList{``0},``1,System.Func{``0,System.Int32,``1,``1})">
            <summary>Form of fold function with element index for convenience.</summary>
            <typeparam name="T">Type of list item.</typeparam>
            <typeparam name="R">Type of result.</typeparam>
            <param name="source">List to fold.</param>
            <param name="initialValue">From were to start.</param>
            <param name="collect">Collects list item into result</param>
            <returns>Return result or <paramref name="initialValue"/> for empty list.</returns>
        </member>
        <member name="M:Marten.Util.ImList.Reverse``1(Marten.Util.ImList{``0})">
            <summary>Returns new list in reverse order.</summary>
            <typeparam name="T">List item type</typeparam> <param name="source">List to reverse.</param>
            <returns>New list. If list consist on single element, then the same list.</returns>
        </member>
        <member name="M:Marten.Util.ImList.Map``2(Marten.Util.ImList{``0},System.Func{``0,``1})">
            <summary>Maps the items from the first list to the result list.</summary>
            <typeparam name="T">source item type.</typeparam>
            <typeparam name="R">result item type.</typeparam>
            <param name="source">input list.</param> <param name="map">converter func.</param>
            <returns>result list.</returns>
        </member>
        <member name="M:Marten.Util.ImList.Map``2(Marten.Util.ImList{``0},System.Func{``0,System.Int32,``1})">
            <summary>Maps the items from the first list to the result list with item index.</summary>
            <typeparam name="T">source item type.</typeparam>
            <typeparam name="R">result item type.</typeparam>
            <param name="source">input list.</param> <param name="map">converter func.</param>
            <returns>result list.</returns>
        </member>
        <member name="M:Marten.Util.ImList.ToArray``1(Marten.Util.ImList{``0})">
            <summary>Copies list to array.</summary>
            <param name="source">list to convert.</param>
            <returns>Array with list items.</returns>
        </member>
        <member name="T:Marten.Util.Update`1">
            <summary>Given the old value should and the new value should return result updated value.</summary>
        </member>
        <member name="T:Marten.Util.ImMap`1">
            <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree with integer keys and <typeparamref name="V"/> values.</summary>
        </member>
        <member name="F:Marten.Util.ImMap`1.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="F:Marten.Util.ImMap`1.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:Marten.Util.ImMap`1.Value">
            <summary>Value.</summary>
        </member>
        <member name="F:Marten.Util.ImMap`1.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:Marten.Util.ImMap`1.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:Marten.Util.ImMap`1.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:Marten.Util.ImMap`1.IsEmpty">
            <summary>Returns true is tree is empty.</summary>
        </member>
        <member name="M:Marten.Util.ImMap`1.AddOrUpdate(System.Int32,`0)">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree.</returns>
        </member>
        <member name="M:Marten.Util.ImMap`1.AddOrUpdate(System.Int32,`0,Marten.Util.Update{`0})">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key">Key</param> <param name="value">Value</param>
            <param name="updateValue">(optional) Delegate to calculate new value from and old and a new value.</param>
            <returns>New tree.</returns>
        </member>
        <member name="M:Marten.Util.ImMap`1.Update(System.Int32,`0)">
            <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree if key is found, or the same tree otherwise.</returns>
        </member>
        <member name="M:Marten.Util.ImMap`1.GetValueOrDefault(System.Int32,`0)">
            <summary>Get value for found key or null otherwise.</summary>
            <param name="key"></param> <param name="defaultValue">(optional) Value to return if key is not found.</param>
            <returns>Found value or <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:Marten.Util.ImMap`1.TryFind(System.Int32,`0@)">
            <summary>Returns true if key is found and sets the value.</summary>
            <param name="key">Key to look for.</param> <param name="value">Result value</param>
            <returns>True if key found, false otherwise.</returns>
        </member>
        <member name="M:Marten.Util.ImMap`1.Enumerate">
            <summary>Returns all sub-trees enumerated from left to right.</summary>
            <returns>Enumerated sub-trees or empty if tree is empty.</returns>
        </member>
        <member name="M:Marten.Util.ImMap`1.Remove(System.Int32)">
            <summary>Removes or updates value for specified key, or does nothing if key is not found.
            Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
            <param name="key">Key to look for.</param>
            <returns>New tree with removed or updated value.</returns>
        </member>
        <member name="M:Marten.Util.ImMap`1.ToString">
            <summary>Outputs key value pair</summary>
        </member>
        <member name="T:Marten.Util.ImHashMap`2">
            <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree
            where node key is the hash code of <typeparamref name="K"/>.</summary>
        </member>
        <member name="F:Marten.Util.ImHashMap`2.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="P:Marten.Util.ImHashMap`2.Hash">
            <summary>Calculated key hash.</summary>
        </member>
        <member name="P:Marten.Util.ImHashMap`2.Key">
            <summary>Key of type K that should support <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="P:Marten.Util.ImHashMap`2.Value">
            <summary>Value of any type V.</summary>
        </member>
        <member name="P:Marten.Util.ImHashMap`2.Conflicts">
            <summary>In case of <see cref="P:Marten.Util.ImHashMap`2.Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        </member>
        <member name="F:Marten.Util.ImHashMap`2.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:Marten.Util.ImHashMap`2.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:Marten.Util.ImHashMap`2.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:Marten.Util.ImHashMap`2.IsEmpty">
            <summary>Returns true if tree is empty.</summary>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.AddOrUpdate(`0,`1)">
            <summary>Returns new tree with added key-value.
            If value with the same key is exist then the value is replaced.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.AddOrUpdate(`0,`1,Marten.Util.Update{`1})">
            <summary>Returns new tree with added key-value. If value with the same key is exist, then
            if <paramref name="update"/> is not specified: then existing value will be replaced by <paramref name="value"/>;
            if <paramref name="update"/> is specified: then update delegate will decide what value to keep.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <param name="update">Update handler.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.Update(`0,`1,Marten.Util.Update{`1})">
            <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/>, or
            runs custom update handler (<paramref name="update"/>) with old and new value to get the updated result.</summary>
            <param name="key">Key to look for.</param>
            <param name="value">New value to replace key value with.</param>
            <param name="update">(optional) Delegate for custom update logic, it gets old and new <paramref name="value"/>
            as inputs and should return updated value as output.</param>
            <returns>New tree with updated value or the SAME tree if no key found.</returns>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.GetValueOrDefault(`0,`1)">
            <summary>Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.</summary>
            <param name="key">Key to look for.</param> <param name="defaultValue">(optional) Value to return if key is not found.</param>
            <returns>Found value or <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.TryFind(`0,`1@)">
            <summary>Returns true if key is found and sets the value.</summary>
            <param name="key">Key to look for.</param> <param name="value">Result value</param>
            <returns>True if key found, false otherwise.</returns>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.Enumerate">
            <summary>Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up (~20% faster than stack).</summary>
            <returns>Sequence of enumerated key value pairs.</returns>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.Remove(`0)">
            <summary>Removes or updates value for specified key, or does nothing if key is not found.
            Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
            <param name="key">Key to look for.</param>
            <returns>New tree with removed or updated value.</returns>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.ToString">
            <summary>Outputs key value pair</summary>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.AddOrUpdate(System.Int32,`0,`1)">
            <summary>It is fine</summary>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.Update(System.Int32,`0,`1,Marten.Util.Update{`1})">
            <summary>It is fine</summary>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.GetConflictedValueOrDefault(`0,`1)">
            <summary>It is fine</summary>
        </member>
        <member name="M:Marten.Util.ImHashMap`2.TryFindConflictedValue(`0,`1@)">
            <summary>It is fine</summary>
        </member>
        <member name="M:Marten.Util.ReflectionExtensions.FullNameInCode(System.Type)">
            <summary>
                Derives the full type name *as it would appear in C# code*
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Util.ReflectionExtensions.NameInCode(System.Type)">
            <summary>
                Derives the type name *as it would appear in C# code*
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Util.TypeMappings.ToDbType(System.Type)">
            <summary>
            Some portion of implementation adapted from Npgsql GlobalTypeMapper.ToNpgsqlDbType(Type type)
            https://github.com/npgsql/npgsql/blob/dev/src/Npgsql/TypeMapping/GlobalTypeMapper.cs
            Possibly this method can be trimmed down when Npgsql eventually exposes ToNpgsqlDbType
            </summary>
        </member>
    </members>
</doc>
